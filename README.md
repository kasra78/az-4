# az-4
ابتدا یک کلاس مستطیل می سازیم
متد های setter و getter را به آن اضافه میکنیم
با توجه به این که امکان تغییر طول و عرض مستطیل وجود دارد و در واقع طول با عرض متفاوت است کلاس مربع نمیتواند از مستطیل ارث بری کند بنا بر این یک کلاس جداگانه میسازیم.


# پرسش‌ها
## سوال ۱
### ۱. اصل Single Responsibility Principle:
برخی به اشتباه از این اصل این را برداشت میکنند که کلاس باید یک کار انجام بدهد در حالی که این اصل به این معناست که کلاس باید فقط یک دلیل برای تغییر داشته باشد، یعنی اینکه اگر ما یک کلاس را بنابر درخواست یکی از ذینفعان تغییر دادیم، مطمئن باشیم ذینفعان دیگری وجود ندارند که منافع و انتظاراتشان بر هم بخورد. اگر این را رعایت کنیم حتی ممکن است کلاس چند کار انجام بدهد ولی با این اصل در تناقض نباشد.

### ۲. اصل Open-Closed Principle:
به این معنی است که کلاس برای گسترش باید باز باشد اما برای تغییر باید بسته باشد. این به این معناست که ما باید بتوانیم راحت به کلاس قابلیت اضافه کنیم بدون اینکه نیاز باشد کدهای قبلی را تغییر دهیم. در صورت عدم رعایت این اصل، وقتی مجبور باشیم برای افزودن قابلیت به کلاس، کدهای قبلی را تغییر دهیم باید حواسمان به محل استفاده کدهای قبلی هم باشد که دچار مشکل نشوند.

### ۳. اصل Liskov Substitution Principle:
یعنی کلاس بچه باید بتواند جایگزین کلاس پدر بشود. به طور خاص به این معنی است که Precondition کلاس بچه نباید از پدر قوی‌تر باشد و Postcondition آن از پدر ضعیف‌تر باشد. یعنی بچه نباید انتظارات بیشتری نسبت به پدرش داشته باشد و امکانات کمتری هم فراهم کند. یعنی اگر پدر ورودی‌ای را دریافت میکند و پاسخ آن را می‌دهد، بچه هم باید آن ورودی را دریافت کند و پاسخ بدهد.

### ۴. اصل Interface Segregation Principle:
طبق این اصل وجود تعداد زیادی واسط که هر کدام یک کار انجام بدهند خیلی بهتر از داشتن یک واسط جامع است که انتظار داشته باشیم کلی کار انجام بدهد.

### ۵. اصل Dependency Inversion Principle:
طبق این اصل کلاس‌های سطح بالا نباید به کلاس‌های سطح پایین وابسته باشند و هر دو باید به یک کلاس Abstract وابسته باشند. همچنین موارد انتزاعی نباید وابسته به جزئیات باشند، بلکه جزئیات باید وابسته به انتزاع باشند.

## سوال ۲
اصول SOLID در گام طراحی استفاده می‌شوند. در واقع زمانی که ما قصد طراحی آبجکت‌های پروژه و طراحی ساختار آبجکت‌ها و نسبت آن‌ها با یکدیگر را داریم دقیقا در موقعیتی هستیم که مرتبط با اصول SOLID است و می‌توانیم از آن‌ها استفاده کنیم.

## سوال ۳
خیر تناقضی ندارند. در مورد اول پس از پیاده‌سازی نرم‌افزار تست‌های موردی برای تست بخش‌های مختلف و معمولا به صورت مجزا صورت میگیرد. اما در روش TDD این تست‌ها مبتنی بر نیازهای پروژه و انتظارات از پروژه طراحی می‌شوند. در این حالت با توجه به تست‌های طراحی‌شده برنامه پیاده‌سازی میشود تا جایی که همه‌ی تست‌ها را پاس کند.

## سوال ۴
در این حالت می‌توانستیم مربع را مستطیلی فرض کنیم که طول و عرض آن با هم برابر است. یعنی مربع یک زیر کلاس از کلاس مستطیل میشد و میتوانستیم با داشتن طول ضلع مربع و استفاده از سازنده مستطیل سازنده مربع را هم پیاده‌سازی کنیم. بقیه‌ی متدها هم از همان کلاس پدر استفاده می‌کردند.
